# API调用说明与问题分析

## 1. `user_points_info_daily` 缓存错误分析

### 业务用途
- **API名称**：`user` API（查询用户积分信息）
- **调用函数**：`utils.py:77-112` - `get_user_points_info()`
- **业务目的**：在UI页面顶部显示用户的Tushare积分信息
  - 总积分
  - 最近到期时间
  - 最近到期批次的积分

### 调用位置
**`app.py:1960-2020`** - 页面顶部积分信息显示
```python
# 积分信息显示（页面顶部）
cache_key = 'user_points_info_daily'

# 先检查持久化缓存（24小时有效，确保一天只调用一次）
points_info = data_cache.get(cache_key)

if points_info is None:
    # 缓存不存在或已过期，需要调用API
    points_info = get_user_points_info()
    # 保存到持久化缓存（24小时有效）
    if points_info:
        data_cache.set(cache_key, points_info)
```

### 缓存机制设计
- **缓存键**：`user_points_info_daily`（固定键名，所有会话共享）
- **缓存时间**：24小时有效
- **设计目的**：确保一天只调用一次API（避免超过50次/天限制）

### 问题分析

#### 错误信息
```
读取缓存失败 user_points_info_daily: Expecting value: line 11 column 17 (char 267)
```

#### 可能原因
1. **缓存文件损坏**：JSON格式错误，可能是：
   - 写入时被中断
   - 文件编码问题
   - 数据序列化问题（包含不可序列化的对象）

2. **缓存数据格式不匹配**：
   - 旧版本缓存格式与新版本不兼容
   - 缓存文件中包含特殊字符

3. **并发写入问题**：
   - 多个会话同时写入缓存文件
   - 导致文件损坏

#### 当前行为
- 缓存读取失败 → 每次页面加载都调用API
- 如果用户频繁刷新页面 → 很容易超过50次/天限制
- **问题**：违背了"一天只调用一次"的设计初衷

### 解决方案建议
1. **修复缓存读取**：
   - 添加JSON解析异常处理
   - 如果缓存文件损坏，自动删除并重新获取
   
2. **增强缓存健壮性**：
   - 写入前先写入临时文件，成功后再替换
   - 添加文件锁，避免并发写入

3. **降级处理**：
   - 如果API调用失败，使用过期缓存（如果有）
   - 如果完全没有缓存，显示"积分信息暂不可用"

---

## 2. `stock_company` API 用途与频率问题

### 业务用途
- **API名称**：`stock_company`（获取上市公司基本信息）
- **调用函数**：`utils.py:325-356` - `fetch_company_info()`
- **业务目的**：获取股票的基本信息，用于显示在分析结果中
  - 公司全称（com_name）
  - 董事长（chairman）
  - 所在地（province, city）
  - 成立日期（setup_date）
  - 主营业务（main_business）
  - 经营范围（business_scope）

### 调用场景

#### 场景1：单项分析（`page_single_analysis()`）
- **调用位置**：`utils.py:577` - `analyze_fundamentals()` 中
- **调用频率**：每只股票分析时调用1次
- **显示位置**：`app.py:897-925` - 显示公司基本信息卡片

#### 场景2：全网筛选（`page_full_market_screening()`）
- **调用位置**：`utils.py:577` - 每只股票分析时调用
- **调用频率**：5274只股票 × 1次 = 5274次
- **并发情况**：10线程并发处理

### API限制
- **限制**：每分钟最多10次
- **最低积分**：120分（您有2000分，满足要求）
- **频率说明**：
  - 每分钟10次 = 每6秒1次
  - 但代码中只延迟0.1秒，远远不够

### 问题分析

#### 当前调用情况
```
全网筛选流程（每只股票）：
1. fetch_company_info() → stock_company API（每分钟10次限制）
2. fetch_audit_records() → fina_audit API
3. fetch_balancesheet() → balancesheet API
4. fetch_income() → income API
5. fetch_cashflow() → cashflow API
```

#### 频率超限计算
- **并发线程数**：10线程
- **API延迟**：0.1秒
- **每只股票调用**：1次 `stock_company` API

**理论计算**：
- 10线程同时启动 → 瞬间调用10次 `stock_company` API
- 0.1秒后，10线程继续处理下一只股票 → 又调用10次
- **1秒内可能调用100次**，远超每分钟10次的限制

**实际场景**：
```
时间轴：
0.0秒：线程1-10同时启动，各调用1次 stock_company → 10次调用（刚好达到限制）
0.1秒：线程1-10继续处理，各调用1次 stock_company → 又10次调用（超限！）
0.2秒：线程1-10继续处理，各调用1次 stock_company → 又10次调用（超限！）
...
```

#### 为什么需要调用这个API？
- **显示公司信息**：在分析结果中显示公司名称、董事长等信息
- **用户体验**：让用户知道分析的是哪家公司
- **但问题**：公司信息很少变化，可以缓存！

### 解决方案建议

#### 方案1：增加缓存机制（推荐）
- **缓存公司信息**：公司信息很少变化，可以长期缓存
- **缓存键**：`company_info_{ts_code}`
- **缓存时间**：30天或永久（公司信息基本不变）
- **效果**：每只股票只调用1次，之后都从缓存读取

#### 方案2：增加专用延迟
- **为 `stock_company` API 设置专用延迟**：至少6秒/次
- **修改位置**：`utils.py:577` - `fetch_company_info()` 调用后
- **问题**：会大幅降低筛选速度（每只股票增加6秒）

#### 方案3：降低并发数
- **降低并发线程数**：从10线程降到2-3线程
- **问题**：筛选速度会变慢

#### 方案4：队列机制
- **为有限制的API使用队列**：确保不超过频率限制
- **实现**：使用队列控制 `stock_company` API调用频率
- **优点**：既保证速度，又不超过限制

---

## 3. 您的积分等级与频率限制

### 当前积分
- **您的积分**：2000分
- **等级**：中级用户（600-4999分）

### 频率限制（根据Tushare文档）
根据您的积分等级，以下是各API的频率限制：

| API类型 | 每分钟调用次数 | 说明 |
|---------|---------------|------|
| 财务数据API | 20次/分钟 | balancesheet, income, cashflow, fina_audit等 |
| stock_company | 10次/分钟 | 公司基本信息（特殊限制） |
| user | 50次/天 | 查询积分信息（每日限制） |
| daily_basic | 20次/分钟 | 每日指标数据 |

### 当前配置问题
- **API延迟**：0.1秒
- **并发线程数**：10线程
- **问题**：
  - 对于 `stock_company`（10次/分钟）：0.1秒延迟不够，需要至少6秒
  - 对于其他财务API（20次/分钟）：0.1秒延迟可以，但10线程并发可能还是太快

---

## 4. 总结与建议

### 问题1：`user_points_info_daily` 缓存错误
- **原因**：缓存文件JSON格式损坏
- **影响**：每次页面加载都调用API，容易超过50次/天限制
- **建议**：
  1. 修复缓存读取异常处理
  2. 如果缓存损坏，自动删除并重新获取
  3. 增强缓存写入的健壮性（临时文件+文件锁）

### 问题2：`stock_company` API 频率超限
- **原因**：10线程并发，0.1秒延迟，瞬间调用超过10次/分钟限制
- **影响**：API调用失败，影响筛选进度
- **建议**：
  1. **最佳方案**：为 `fetch_company_info()` 增加缓存机制（30天或永久）
  2. **备选方案**：为 `stock_company` API 设置专用延迟（6秒/次）
  3. **备选方案**：使用队列机制控制调用频率

### 优化建议优先级
1. **P0（立即修复）**：
   - 修复 `user_points_info_daily` 缓存读取问题
   - 为 `fetch_company_info()` 增加缓存机制

2. **P1（重要优化）**：
   - 为 `stock_company` API 设置专用延迟或队列机制
   - 增强所有缓存的健壮性（临时文件+文件锁）

3. **P2（可选优化）**：
   - 降低并发线程数（如果缓存生效，可以保持10线程）
   - 添加API调用频率监控和自动调整

